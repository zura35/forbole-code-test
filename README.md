# Development

## DB Migration
```
$ docker compose up db -d
$ make migrate
```

## Run App
```
$ docker compose build app
...
$ docker compose up app
```

## Makefile
| Command | Description |
| -- | -- |
| `make tools` | Install mockery, golang-migrate and sqlc with `brew` |
| `make mock` | Generate mocks with mockery |
| `make sqlc` | Generate sql codes with sqlc |
| `make db-schema` | Dump schema.sql to `db/sqlc` for sqlc generation |
| `make migration NAME=xxx` | Create db migration files in `db/migrations` |
| `make migrate` | Run migrations on database |
| `make test` | Run all tests (including integration tests) |
| `make unit-test` | Run tests excluding integration tests |

# Project Structure
```
.
├── cmd                     // entry point for the application
│   └── user_etl
├── db                      // database related operations that are not 
│   ├── migrations          // migration files that define the table schemas
│   └── sqlc                // sqlc config for generating codes
├── model                   // data models for business logic
├── provider                // implementations for external data providers
│   └── source              // data providers source definitions
├── repository              // implementations for data stores
├── service                 // implementations for business logics
│   └── mock                // mocks of external dependencies
└── sqlc_generated          // codes generated by sqlc
```

# Possible Enhancements
1. Project assumes contributors work with MacOS (e.g. Makefile installs via `brew`). Can possibly install tools inside a docker container but might be slow when building the docker container.
1. Pipelines to run linter, vulnerability check, formatting, integration tests and build can be included in CI.
1. Probably better naming for some of the struct and package names, e.g. `sqlc_generated` package, struct names defined in `/source`.
1. Environment variables retrieval and database connection establishment codes could be wrapped into packages.
1. For simplicity, `address` is stored as a JSONB column. It might be suggested that the `address` column be stored in a separate table with user ID as foreign key or primary key (if user has a 1:1 mapping with address).
1. Include logger in codes.
1. Handle client timeout in provider, e.g. use timeout context with `NewRequestWithContext`.